{"ast":null,"code":"\n\n\n\n\n\n\n\n\n'use strict';\n\nexports.__esModule = true;\nexports.computeWindowedRenderLimits = computeWindowedRenderLimits;\nexports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;\nexports.newRangeCount = newRangeCount;\nexports.default = void 0;\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\nfunction _interopRequireDefault(obj) {return obj && obj.__esModule ? obj : { default: obj };}\n\n\n\n\n\n\nfunction elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\n  var out = [];\n  var outLength = 0;\n\n  for (var ii = 0; ii < itemCount; ii++) {\n    var frame = getFrameMetrics(ii);\n    var trailingOffset = frame.offset + frame.length;\n\n    for (var kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n\n        if (kk === offsets.length - 1) {\n          (0, _invariant.default)(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));\n          return out;\n        }\n      }\n    }\n  }\n\n  return out;\n}\n\n\n\n\n\n\n\n\nfunction newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\n\n\n\n\n\n\n\n\nfunction computeWindowedRenderLimits(props, prev, getFrameMetricsApprox, scrollMetrics) {\n  var data = props.data,\n  getItemCount = props.getItemCount,\n  maxToRenderPerBatch = props.maxToRenderPerBatch,\n  windowSize = props.windowSize;\n  var itemCount = getItemCount(data);\n\n  if (itemCount === 0) {\n    return prev;\n  }\n\n  var offset = scrollMetrics.offset,\n  velocity = scrollMetrics.velocity,\n  visibleLength = scrollMetrics.visibleLength;\n\n\n\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength;\n\n  var leadFactor = 0.5;\n\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n\n  if (lastItemOffset < overscanBegin) {\n\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1 };\n\n  }\n\n\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props.getItemCount(props.data), getFrameMetricsApprox),\n  overscanFirst = _elementsThatOverlapO[0],\n  first = _elementsThatOverlapO[1],\n  last = _elementsThatOverlapO[2],\n  overscanLast = _elementsThatOverlapO[3];\n\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first: first,\n    last: last };\n\n\n\n\n\n  var newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n\n      break;\n    }\n\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n\n\n\n\n      break;\n    }\n\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n\n      first--;\n    }\n\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n\n      last++;\n    }\n  }\n\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first: first,\n      last: last,\n      itemCount: itemCount,\n      overscanFirst: overscanFirst,\n      overscanLast: overscanLast,\n      visible: visible }));\n\n  }\n\n  return {\n    first: first,\n    last: last };\n\n}\n\nvar VirtualizeUtils = {\n  computeWindowedRenderLimits: computeWindowedRenderLimits,\n  elementsThatOverlapOffsets: elementsThatOverlapOffsets,\n  newRangeCount: newRangeCount };\n\nvar _default = VirtualizeUtils;\nexports.default = _default;","map":{"version":3,"names":["exports","__esModule","computeWindowedRenderLimits","elementsThatOverlapOffsets","newRangeCount","default","_invariant","_interopRequireDefault","require","obj","offsets","itemCount","getFrameMetrics","out","outLength","ii","frame","trailingOffset","offset","length","kk","JSON","stringify","prev","next","last","first","Math","max","min","props","getFrameMetricsApprox","scrollMetrics","data","getItemCount","maxToRenderPerBatch","windowSize","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","_elementsThatOverlapO","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","VirtualizeUtils","_default"],"sources":["D:/workbridge/mProjects/GlobalNewsApp/global_news_rn/node_modules/react-native-web/dist/cjs/vendor/react-native/VirtualizeUtils/index.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nexports.__esModule = true;\nexports.computeWindowedRenderLimits = computeWindowedRenderLimits;\nexports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;\nexports.newRangeCount = newRangeCount;\nexports.default = void 0;\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nfunction elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\n  var out = [];\n  var outLength = 0;\n\n  for (var ii = 0; ii < itemCount; ii++) {\n    var frame = getFrameMetrics(ii);\n    var trailingOffset = frame.offset + frame.length;\n\n    for (var kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n\n        if (kk === offsets.length - 1) {\n          (0, _invariant.default)(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));\n          return out;\n        }\n      }\n    }\n  }\n\n  return out;\n}\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\n\n\nfunction newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\n\n\nfunction computeWindowedRenderLimits(props, prev, getFrameMetricsApprox, scrollMetrics) {\n  var data = props.data,\n      getItemCount = props.getItemCount,\n      maxToRenderPerBatch = props.maxToRenderPerBatch,\n      windowSize = props.windowSize;\n  var itemCount = getItemCount(data);\n\n  if (itemCount === 0) {\n    return prev;\n  }\n\n  var offset = scrollMetrics.offset,\n      velocity = scrollMetrics.velocity,\n      visibleLength = scrollMetrics.visibleLength; // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength; // Considering velocity seems to introduce more churn than it's worth.\n\n  var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  } // Find the indices that correspond to the items at the render boundaries we're targeting.\n\n\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props.getItemCount(props.data), getFrameMetricsApprox),\n      overscanFirst = _elementsThatOverlapO[0],\n      first = _elementsThatOverlapO[1],\n      last = _elementsThatOverlapO[2],\n      overscanLast = _elementsThatOverlapO[3];\n\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first: first,\n    last: last\n  }; // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n\n  var newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n\n      first--;\n    }\n\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n\n      last++;\n    }\n  }\n\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first: first,\n      last: last,\n      itemCount: itemCount,\n      overscanFirst: overscanFirst,\n      overscanLast: overscanLast,\n      visible: visible\n    }));\n  }\n\n  return {\n    first: first,\n    last: last\n  };\n}\n\nvar VirtualizeUtils = {\n  computeWindowedRenderLimits: computeWindowedRenderLimits,\n  elementsThatOverlapOffsets: elementsThatOverlapOffsets,\n  newRangeCount: newRangeCount\n};\nvar _default = VirtualizeUtils;\nexports.default = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}